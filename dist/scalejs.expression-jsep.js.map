{"version":3,"sources":["../src/scalejs.expression-jsep.js"],"names":["getIdentifiers","term","parseTree","ex","console","warn","ids","collectIds","tree","Object","keys","forEach","key","type","indexOf","name","push","internalEval","value","undefined","isFinite","Number","JSON","stringify","evaluate","mapFunc","opts","binary","unary","op","addBinaryOp","addUnaryOp","error","removeBinaryOp","removeUnaryOp","expr","returnVal","left","right","test","consequent","alternate","operator","eval","argument","object","property","callee","arguments","map","arg","Function","apply","elements"],"mappings":"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","file":"scalejs.expression-jsep.js","sourcesContent":["import jsep from 'jsep';\r\nimport { unwrap } from 'knockout';\r\n\r\nfunction getIdentifiers(term) {\r\n    // TODO: error checking for poorly formatted expressions\r\n    try {\r\n        var parseTree = jsep(term);\r\n    } catch (ex) {\r\n        console.warn('Left term is poorly formatted: ' + term);\r\n        return [];\r\n    }\r\n\r\n    var ids = [];\r\n    //console.log(parseTree);\r\n    function collectIds(tree) {\r\n        Object.keys(tree).forEach(function (key) {\r\n            if (key === 'left' || key === 'right' || key === 'argument') {\r\n                if (tree[key].type === 'Identifier') {\r\n                    // check for uniqueness o f idntifier\r\n                    if (ids.indexOf(tree[key].name) === -1) {\r\n                        ids.push(tree[key].name);\r\n                    }\r\n                } else {\r\n                    collectIds(tree[key]);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    collectIds(parseTree);\r\n    return ids;\r\n}\r\n\r\nfunction internalEval(value) {\r\n    return value === 'true' || value === true ? true :\r\n        value === 'false' || value === false ? false :\r\n            value === '' || value === null ? '\"\"' :\r\n                value === 'undefined' || value === undefined ? undefined :\r\n                    isFinite(Number(value)) ? Number(value) :\r\n                        typeof value === 'object' ? JSON.stringify(value) :\r\n                            '\"' + value + '\"';\r\n}\r\n\r\nfunction evaluate(term, mapFunc, opts) {\r\n\r\n    opts = opts || {};\r\n    opts.binary = opts.binary || {};\r\n    opts.unary = opts.unary || {};\r\n\r\n    Object.keys(opts.binary).forEach(function (op) {\r\n        jsep.addBinaryOp(op, 10);\r\n    });\r\n    Object.keys(opts.unary).forEach(function (op) {\r\n        jsep.addUnaryOp(op);\r\n    });\r\n\r\n    var parseTree;\r\n    try {\r\n        parseTree = jsep(term);\r\n    } catch (ex) {\r\n        console.error('error evaluating expr: ' + term, ex);\r\n        return '';\r\n    }\r\n\r\n    Object.keys(opts.binary).forEach(function (op) {\r\n        jsep.removeBinaryOp(op);\r\n    });\r\n    Object.keys(opts.unary).forEach(function (op) {\r\n        jsep.removeUnaryOp(op);\r\n    });\r\n\r\n\r\n    function expr(tree) {\r\n        var returnVal,\r\n            left,\r\n            right,\r\n            test,\r\n            consequent,\r\n            alternate;\r\n\r\n        switch (tree.type) {\r\n            case 'BinaryExpression':\r\n                left = expr(tree.left);\r\n                right = expr(tree.right);\r\n\r\n                left = internalEval(left);\r\n                right = internalEval(right);;\r\n\r\n                tree.left.value = left;\r\n                tree.right.value = right;\r\n\r\n                try {\r\n                    if (Object.keys(opts.binary).indexOf(tree.operator) > -1) {\r\n                        returnVal = opts.binary[tree.operator](left, right);\r\n                    } else if (opts.evaluate) {\r\n                        returnVal = opts.evaluate(tree.operator, left, right);\r\n                    } else {\r\n                        returnVal = eval(left + ' ' + tree.operator + ' ' + right);\r\n                    }\r\n                } catch (ex) {\r\n                    console.error('error parsing expr:', parseTree, ex);\r\n                    return '';\r\n                }\r\n                //console.log('binary:', tree.left.value, tree.operator, tree.right.value, returnVal);\r\n                return returnVal;\r\n            case 'UnaryExpression':\r\n                var value = expr(tree.argument);\r\n                value = internalEval(value);\r\n                tree.argument.value = value;\r\n                try {\r\n                    if (Object.keys(opts.unary).indexOf(tree.operator) > -1) {\r\n                        returnVal = opts.unary[tree.operator](tree.argument);\r\n                    } else if (opts.evaluate) {\r\n                        returnVal = opts.evaluate(tree.operator, tree.argument);\r\n                    } else {\r\n                        returnVal = eval(tree.operator + tree.argument.value);\r\n                    }\r\n                } catch (ex) {\r\n                    console.error('error parsing expr:', parseTree, ex);\r\n                    return '';\r\n                }\r\n                //console.log('unary:', tree.operator, tree.argument.value, returnVal);\r\n                return returnVal;\r\n            case 'LogicalExpression':\r\n                left = expr(tree.left);\r\n                left = internalEval(left);\r\n                tree.left.value = left;\r\n\r\n                if((tree.operator === '&&' && !left) || (tree.operator === '||' && left)) { //short-circuit\r\n                    returnVal = left;\r\n                    tree.left.value = left;\r\n                } else {\r\n                    right = expr(tree.right);\r\n                    right = internalEval(right);\r\n                    tree.right.value = right;\r\n\r\n                    try {\r\n                        returnVal = eval(left + tree.operator + right);\r\n                    } catch (ex) {\r\n                        console.error('There was an error when parsing expression', parseTree, ex);\r\n                        return '';\r\n                    }                    \r\n                }\r\n\r\n                //console.log('Logical Operation:', tree.left.value, tree.operator, tree.right.value, returnVal);\r\n                return returnVal;\r\n            case 'Identifier':\r\n                returnVal = mapFunc(tree.name);\r\n                return returnVal;\r\n            case 'Literal':\r\n                returnVal = tree.value;\r\n                return returnVal;\r\n            case 'MemberExpression':\r\n                tree.object = expr(tree.object);\r\n                // unwrap is used as an object may have observable values..?\r\n                if (tree.property.type == 'Identifier') {\r\n                    tree.property.value = tree.property.name;\r\n                } else {\r\n                    tree.property.value = expr(tree.property);\r\n                }\r\n                returnVal = unwrap((tree.object || {})[tree.property.value]);\r\n                return returnVal;\r\n            case 'CallExpression':\r\n                    returnVal = '';\r\n                    var callee = expr(tree.callee);\r\n                    tree.arguments = tree.arguments.map(function (arg) {\r\n                        return expr(arg);\r\n                    });\r\n                    if (callee instanceof Function) {\r\n                        returnVal = callee.apply(tree.callee.object, tree.arguments);\r\n                    }\r\n                    return returnVal;\r\n            case 'ArrayExpression':\r\n                returnVal = tree.elements.map(function (arg) {\r\n                    return expr(arg);\r\n                });\r\n                return returnVal;\r\n            case 'ConditionalExpression':\r\n                test = expr(tree.test);\r\n                if(test) {\r\n                    returnVal = expr(tree.consequent);\r\n                } else {\r\n                    returnVal = expr(tree.alternate);\r\n                }\r\n                return returnVal;\r\n            default:\r\n                return tree.value;\r\n        }\r\n    }\r\n\r\n    return expr(parseTree);\r\n}\r\n\r\nexport {\r\ngetIdentifiers,\r\nevaluate\r\n}\r\n"]}