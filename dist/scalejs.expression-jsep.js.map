{"version":3,"sources":["../src/scalejs.expression-jsep.js"],"names":[],"mappings":"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","file":"scalejs.expression-jsep.js","sourcesContent":["import jsep from 'jsep';\nimport { unwrap } from 'knockout';\n\nfunction getIdentifiers(term) {\n    // TODO: error checking for poorly formatted expressions\n    try {\n        var parseTree = jsep(term);\n    } catch (ex) {\n        console.warn('Left term is poorly formatted: ' + term);\n        return [];\n    }\n\n    var ids = [];\n    //console.log(parseTree);\n    function collectIds(tree) {\n        Object.keys(tree).forEach(function (key) {\n            if (key === 'left' || key === 'right' || key === 'argument') {\n                if (tree[key].type === 'Identifier') {\n                    // check for uniqueness o f idntifier\n                    if (ids.indexOf(tree[key].name) === -1) {\n                        ids.push(tree[key].name);\n                    }\n                } else {\n                    collectIds(tree[key]);\n                }\n            }\n        });\n    }\n\n    collectIds(parseTree);\n    return ids;\n}\n\nfunction evaluate(term, mapFunc, opts) {\n\n    opts = opts || {};\n    opts.binary = opts.binary || {};\n    opts.unary = opts.unary || {};\n\n    Object.keys(opts.binary).forEach(function (op) {\n        jsep.addBinaryOp(op, 10);\n    });\n    Object.keys(opts.unary).forEach(function (op) {\n        jsep.addUnaryOp(op);\n    });\n\n    var parseTree;\n    try {\n        parseTree = jsep(term);\n    } catch (ex) {\n        console.error('error evaluating expr: ' + term, ex);\n        return '';\n    }\n\n    Object.keys(opts.binary).forEach(function (op) {\n        jsep.removeBinaryOp(op);\n    });\n    Object.keys(opts.unary).forEach(function (op) {\n        jsep.removeUnaryOp(op);\n    });\n\n\n    function expr(tree) {\n        var returnVal,\n            left,\n            right;\n\n        switch (tree.type) {\n            case 'BinaryExpression':\n                left = expr(tree.left);\n                right = expr(tree.right);\n\n                left = left === 'true' || left === true ? true :\n                    left === 'false' || left === false ? false :\n                        left === '' || left === null ? '\"\"' :\n                            left === 'undefined' || left === undefined ? undefined :\n                                isFinite(Number(left)) ? Number(left) :\n                                    typeof left === 'object' ? JSON.stringify(left) :\n                                        '\"' + left + '\"';\n                right = right === 'true' || right === true ? true :\n                    right === 'false' || right === false ? false :\n                        right === '' || right === null ? '\"\"' :\n                            right === 'undefined' || right === undefined ? undefined :\n                                isFinite(Number(right)) ? Number(right) :\n                                    typeof right === 'object' ? JSON.stringify(right) :\n                                        '\"' + right + '\"';\n\n                tree.left.value = left;\n                tree.right.value = right;\n\n                try {\n                    if (Object.keys(opts.binary).indexOf(tree.operator) > -1) {\n                        returnVal = opts.binary[tree.operator](left, right);\n                    } else if (opts.evaluate) {\n                        returnVal = opts.evaluate(tree.operator, left, right);\n                    } else {\n                        returnVal = eval(left + ' ' + tree.operator + ' ' + right);\n                    }\n                } catch (ex) {\n                    console.error('error parsing expr:', parseTree, ex);\n                    return '';\n                }\n                //console.log('binary:', tree.left.value, tree.operator, tree.right.value, returnVal);\n                return returnVal;\n\n            case 'UnaryExpression':\n                var value = expr(tree.argument);\n                value = value === 'true' || value === true ? true :\n                    value === 'false' || value === false ? false :\n                        value === '' || value === null ? '\"\"' :\n                            value === 'undefined' || value === undefined ? undefined :\n                                isFinite(Number(value)) ? Number(value) :\n                                    typeof value === 'object' ? JSON.stringify(value) :\n                                        '\"' + value + '\"';\n                tree.argument.value = value;\n                try {\n                    if (Object.keys(opts.unary).indexOf(tree.operator) > -1) {\n                        returnVal = opts.unary[tree.operator](tree.argument);\n                    } else if (opts.evaluate) {\n                        returnVal = opts.evaluate(tree.operator, tree.argument);\n                    } else {\n                        returnVal = eval(tree.operator + tree.argument.value);\n                    }\n                } catch (ex) {\n                    console.error('error parsing expr:', parseTree, ex);\n                    return '';\n                }\n                //console.log('unary:', tree.operator, tree.argument.value, returnVal);\n                return returnVal;\n            case 'LogicalExpression':\n                left = expr(tree.left);\n                right = expr(tree.right);\n\n                left = left === 'true' || left === true ? true :\n                    left === 'false' || left === false ? false :\n                        left === '' || left === null ? '\"\"' :\n                            left === 'undefined' || left === undefined ? undefined :\n                                isFinite(Number(left)) ? Number(left) :\n                                    typeof left === 'object' ? JSON.stringify(left) :\n                                        '\"' + left + '\"';\n                right = right === 'true' || right === true ? true :\n                    right === 'false' || right === false ? false :\n                        right === '' || right === null ? '\"\"' :\n                            right === 'undefined' || right === undefined ? undefined :\n                                isFinite(Number(right)) ? Number(right) :\n                                    typeof right === 'object' ? JSON.stringify(right) :\n                                        '\"' + right + '\"';\n\n                tree.left.value = left;\n                tree.right.value = right;\n\n                try {\n                    returnVal = eval(left + tree.operator + right);\n                } catch (ex) {\n                    console.error('There was an error when parsing expression', parseTree, ex);\n                    return '';\n                }\n                //console.log('Logical Operation:', tree.left.value, tree.operator, tree.right.value, returnVal);\n                return returnVal;\n            case 'Identifier':\n                returnVal = mapFunc(tree.name);\n                return returnVal;\n            case 'MemberExpression':\n                tree.object = expr(tree.object);\n                // unwrap is used as an object may have observable values..?\n                if (tree.property.type == 'Identifier') {\n                    tree.property.value = tree.property.name;\n                } else {\n                    tree.property.value = expr(tree.property);\n                }\n                returnVal = unwrap((tree.object || {})[tree.property.value]);\n                return returnVal;\n            case 'CallExpression':\n                returnVal = '';\n                tree.callee = expr(tree.callee);\n                tree.arguments = tree.arguments.map(function (arg) {\n                    return expr(arg);\n                });\n                if (tree.callee instanceof Function) {\n                    returnVal = tree.callee.apply(this, tree.arguments);\n                }\n                return returnVal;\n            case 'ArrayExpression':\n                returnVal = tree.elements.map(function (arg) {\n                    return expr(arg);\n                });\n                return returnVal;\n            default:\n                return tree.value;\n        }\n    }\n\n    return expr(parseTree);\n}\n\nexport {\ngetIdentifiers,\nevaluate\n}\n\n"]}